#!/bin/sh
## configure 参数生成的路径（用于调试）
export tmp_config=my_config

## make 参数
MKTHD="-j 30"

#export BUILD_HOST=arm-linux
export BUILD_HOST=arm-linux-gnueabi
## 必要时，填写你的工具链的所在路径
BUILD_HOST_PATH=/opt/gcc-arm-linux-gnueabi/bin

## 路径管理
export BASE=`pwd`
export CODE_PATH=${BASE}/source/
export OUTPUT_PATH=${BASE}/install/
export ARCHIVE_PATH=${BASE}/compressed

## 工具链
export BUILD_HOST_=""
if [ -z "${BUILD_HOST}"  ]; then
   export BUILD_HOST_=""
else
   export BUILD_HOST_=${BUILD_HOST}-
fi
export _CC="${BUILD_HOST_}gcc"
export _CPP="${BUILD_HOST_}g++"
export _CXX="${BUILD_HOST_}g++"
export _LD="${BUILD_HOST_}ld"
export _AR="${BUILD_HOST_}ar"
export _RANLIB="${BUILD_HOST_}ranlib"
export _STRIP="${BUILD_HOST_}strip"


function set_compile_env_for_target () {
    export CC=${_CC}
    export CXX=${_CXX}
    export AR=${_AR}
    export LD=${_LD}
    export RANLIB=${_RANLIB}
    export STRIP=${_STRIP}
}


## 添加环境变量
if [ -d "${BUILD_HOST_PATH}"  ]; then
    export PATH=${PATH}:${BUILD_HOST_PATH}
fi

# 获取 工具链所在位置 下面的操作为的是在 CMakeLists.txt 中插入下面内容
##export GCC_FULL_PATH=`whereis ${_CC} | awk -F: '{ print $2 }' | awk '{print $1}'` # 防止多个结果
##export GCC_DIR=`dirname ${GCC_FULL_PATH}/`

function make_dirs () {
    #为了方便管理，创建有关的目录
    mkdir -pv $CODE_PATH
    mkdir -pv $OUTPUT_PATH
    mkdir -pv $ARCHIVE_PATH
}

function tget () { #try wget
    local filename=`basename $1`
bash <<EOF
    cd ${ARCHIVE_PATH}
    echo "Downloading [${filename}]..."
    if [ ! -f ${filename} ];then
        wget "$@"
    fi

    echo "[OK] Downloaded [${filename}] "
EOF
}

function tgit () { #try git and tar
    local filename=`basename $1 | sed 's/.git//g'`

bash <<EOF
    cd ${ARCHIVE_PATH}
    echo "Clone [${filename}]..."
    if [ ! -f ${filename}.tgz ];then
        git clone $1
        rm ${filename}/.git* -rf
        echo "Making a tar file."
        tar -zcf ${filename}.tgz ${filename}
        rm ${filename} -rf
    fi

    echo "[OK] Cloned [${filename}] "
EOF
}

function tar_package () {
bash <<EOF
    cd ${ARCHIVE_PATH}
    for TAR in \`find . -maxdepth 1 -mindepth 1 -type f\`
    do
        tarfile=\`basename \$TAR\`
        filename=\`echo \${tarfile}| sed 's/.tar.gz//'| sed 's/.tgz//'| sed 's/.tar.bz2//'\`
        #if [ ! -d "${CODE_PATH}/\`basename \$TAR\`" ]; then
        if [ ! -d "${CODE_PATH}/\${filename}" ]; then
            echo "Untar \$tarfile..."
            tar -xf \$TAR -C  ${CODE_PATH}
        else
            echo "Skip \$tarfile..."
        fi
    done
EOF
}

function require () {
    echo "Checking [$1]"
    command -v $1 >/dev/null 2>&1 || { echo >&2 "Aborted : Require \"$1\" but not found."; exit 1; }
}

make_dirs
require ${_CC}     || return 1
require ${_CPP}    || return 1
require ${_AR}     || return 1
require ${_LD}     || return 1
require ${_RANLIB} || return 1
require ${_STRIP}  || return 1


## 常见的移植
export ZLIB=zlib-1.2.11
export OPENSSL=openssl-1.0.2t
### ZLIB
function get_zlib () {
    tget https://www.zlib.net/${ZLIB}.tar.gz
}

function make_zlib () {
bash <<EOF
    cd ${CODE_PATH}/${ZLIB}
    CC=${_CC} ./configure --prefix=${OUTPUT_PATH}/${ZLIB}
    make clean
    make $MKTHD && make install
EOF
}

### OPENSSL
function get_ssl () {
    tget  https://www.openssl.org/source/${OPENSSL}.tar.gz
}

# 删除不需要的Makefile的doc规则
# 这部分规则容易引起Makefile死循环
function pre_make_ssl () {
    bash <<EOF
    cd ${BASE}/source/${OPENSSL}
    startLine=\`sed -n '/install_html_docs\:/=' Makefile\`
    echo \$startLine
    for startline in \$startLine # 避免多行结果
    do
        endLine=\`expr \$startline + 999\`
        sed -i \$startline','\$endLine'd' Makefile
        echo "install_html_docs:" >> Makefile
        echo -e "\t@echo skip by Schips" >> Makefile
        echo "install_docs:" >> Makefile
        echo -e "\t@echo skip by Schips" >> Makefile
        echo "# DO NOT DELETE THIS LINE -- make depend depends on it." >> Makefile
        break
    done
EOF
}
function make_ssl () {
    pre_make_ssl || return 1
    bash <<EOF

    cd ${BASE}/source/${OPENSSL}
    echo "SSL ABOUT"
    CC=${_CC} ./config no-asm shared --prefix=${OUTPUT_PATH}/${OPENSSL}

    sed 's/-m64//g'  -i Makefile # 删除-m64 关键字 (arm-gcc 不支持)
    #sudo mv /usr/bin/pod2man /usr/bin/pod2man_bak
    #mv doc/apps /tmp/
    make $MKTHD && make install
EOF
}

