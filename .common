#!/bin/sh
## configure 参数生成的路径（用于调试）
export tmp_config=my_config

## make 参数
MKTHD="-j 30"


# 编译架构
export BUILD_ARCH=arm64
#export BUILD_ARCH=arm

#export BUILD_HOST=arm-linux
export BUILD_HOST=arm-linux-gnueabi
## 必要时，填写你的工具链的所在路径
BUILD_HOST_PATH=/opt/gcc-arm-linux-gnueabi/bin

## 路径管理
export BASE=`pwd`
export CODE_PATH=${BASE}/source/
export OUTPUT_PATH=${BASE}/install/
export ARCHIVE_PATH=${BASE}/compressed

## 工具链
export BUILD_HOST_=""
if [ -z "${BUILD_HOST}"  ]; then
   export BUILD_HOST_=""
else
   export BUILD_HOST_=${BUILD_HOST}-
fi
export _CC="${BUILD_HOST_}gcc"
export _CPP="${BUILD_HOST_}g++"
export _CXX="${BUILD_HOST_}g++"
export _LD="${BUILD_HOST_}ld"
export _AR="${BUILD_HOST_}ar"
export _RANLIB="${BUILD_HOST_}ranlib"
export _STRIP="${BUILD_HOST_}strip"


function set_compile_env_for_target () {
    export CC=${_CC}
    export CXX=${_CXX}
    export AR=${_AR}
    export LD=${_LD}
    export RANLIB=${_RANLIB}
    export STRIP=${_STRIP}
}


## 添加环境变量
if [ -d "${BUILD_HOST_PATH}"  ]; then
    export PATH=${PATH}:${BUILD_HOST_PATH}
fi

# 获取 工具链所在位置 下面的操作为的是在 CMakeLists.txt 中插入下面内容
##export GCC_FULL_PATH=`whereis ${_CC} | awk -F: '{ print $2 }' | awk '{print $1}'` # 防止多个结果
##export GCC_DIR=`dirname ${GCC_FULL_PATH}/`

function make_dirs () {
    #为了方便管理，创建有关的目录
    mkdir -pv $CODE_PATH
    mkdir -pv $OUTPUT_PATH
    mkdir -pv $ARCHIVE_PATH
}

function tget () { #try wget
    local filename=`basename $1`
bash <<EOF
    cd ${ARCHIVE_PATH}
    echo "Downloading [${filename}]..."
    if [ ! -f ${filename} ];then
        wget "$@"
    fi

    echo "[OK] Downloaded [${filename}] "
EOF
}

# 适用于 例如github等情况 https://github.com/<author>/<repo>/archive/refs/tags/va.b.c.tar.gz
# $1 : url
# $2 : local file name
function tget_and_rename () { #try wget
    local filename=`basename $1`
    local output="$2"
    if [ ! -z "$output" ]; then
        filename="$output"
    fi
    echo $all
bash <<EOF
    cd ${ARCHIVE_PATH}
    echo "Downloading [${filename}]..."
    if [ ! -f ${filename} ];then
        wget $1 -O $filename
    fi

    echo "[OK] Downloaded [${filename}] "
EOF
}

function tgit () { #try git and tar
    local filename=`basename $1 | sed 's/.git//g'`

bash <<EOF
    cd ${ARCHIVE_PATH}
    echo "Clone [${filename}]..."
    if [ ! -f ${filename}.tgz ];then
        git clone $1
        rm ${filename}/.git* -rf
        echo "Making a tar file."
        tar -zcf ${filename}.tgz ${filename}
        rm ${filename} -rf
    fi

    echo "[OK] Cloned [${filename}] "
EOF
}

function tar_package () {
bash <<EOF
    cd ${ARCHIVE_PATH}
    for TAR in \`find . -maxdepth 1 -mindepth 1\`
    do
        if [ -d  \$TAR ]; then
            continue
        fi
        tarfile=\`basename \$TAR\`
        filename=\`echo \${tarfile}| sed 's/.tar.gz//'| sed 's/.tgz//'| sed 's/.tar.bz2//'\`
        if [ ! -d "${CODE_PATH}/\${filename}" ]; then
            echo "Untar \$tarfile..."
            tar -xf \$TAR -C  ${CODE_PATH}
        else
            echo "Skip \$tarfile..."
        fi
    done
EOF
}

# 将含有关键字的行替换为新的内容
function file_replace_match_lines(){
    local fin=$1
    local old=$2
    local new=$3
    if [ -z "$fin" ]; then
        echo "$0 file old new"
        return 1
    fi
    local oldt=`echo $old| sed 's:\/:\\\/:g'`
    local newt=`echo $new| sed 's:\/:\\\/:g'`
    bash <<EOF
sed -r -i "/$oldt/ s/.*/$newt/1" -i $fin
EOF

}
function mk_softlink_to_dest()
{
    local src="$1"
    local dst="$2"

    if [ ! -f $src ]; then
        echo "Need a file."
        return 1
    fi

    local full_path_src=`readlink -f $src`
    local full_path_dst=`readlink -f $dst`
    if [ "$full_path_dst" =  "$full_path_src" ]; then
        echo "Skip, same path."
    else
        unlink $dst > /dev/null 2>&1
        ln -s $full_path_src $dst  2>&1
    fi
}

function require () {
    echo "Checking [$1]"
    command -v $1 >/dev/null 2>&1 || { echo >&2 "Aborted : Require \"$1\" but not found."; exit 1; }
}

make_dirs
require ${_CC}     || return 1
require ${_CPP}    || return 1
require ${_AR}     || return 1
require ${_LD}     || return 1
require ${_RANLIB} || return 1
require ${_STRIP}  || return 1

# 如果需要看到 过程，则 在使用时随便提供一个参数
#export SHVERBOSE=$1
#export SHVERBOSE=1

# getArg0
if [ -z "${BASH_SOURCE[0]}" ]; then
#as zsh
A0=$0
else
#as bash
A0=${BASH_SOURCE[0]}
fi
export ROOT_DIR=`dirname $A0`
export THIS_SH=`basename $A0`
export COMMON_SH_DIR=$ROOT_DIR/.common_lib

# 初始各组件的编译脚本
load_shells () {
    for sh_file in `cd $COMMON_SH_DIR; find . -type f -name "*.sh" | grep -v "$THIS_SH" | grep -v ".todo/" | grep -v ".ref/" | sed 's/..//'`
    do
        source $COMMON_SH_DIR/$sh_file

        if [ ! -z "$SHVERBOSE" ]; then
            echo "Source $sh_file"
        fi

    done
}
load_shells
