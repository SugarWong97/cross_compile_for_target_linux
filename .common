#!/bin/sh
## configure 参数生成的路径（用于调试）
export tmp_config=my_config

## make 参数
MKTHD="-j 30"

#export BUILD_HOST=arm-linux
export BUILD_HOST=arm-none-linux-gnueabi
## 必要时，填写你的工具链的所在路径
BUILD_HOST_PATH=/opt/gcc-arm-linux-gnueabi/bin

## 路径管理
export BASE=`pwd`
export CODE_PATH=${BASE}/source/
export OUTPUT_PATH=${BASE}/install/
export ARCHIVE_PATH=${BASE}/compressed

## 工具链
export BUILD_HOST_=""
if [ -z "${BUILD_HOST}"  ]; then
   export BUILD_HOST_=""
else
   export BUILD_HOST_=${BUILD_HOST}-
fi
export _CC="${BUILD_HOST_}gcc"
export _CPP="${BUILD_HOST_}g++"
export _LD="${BUILD_HOST_}ld"
export _AR="${BUILD_HOST_}ar"
export _RANLIB="${BUILD_HOST_}ranlib"
export _STRIP="${BUILD_HOST_}strip"


## 常见的移植
### ZLIB
export ZLIB=zlib-1.2.11
function make_zlib () {
function _make_sh () {
cat<<EOF
    CC=${_CC} ./configure --prefix=${OUTPUT_PATH}/${ZLIB}
EOF
}
    # 编译安装 zlib （因为很多库用到了，所以放在这里）
    cd ${CODE_PATH}/${ZLIB}

    _make_sh > $tmp_config
    source ./$tmp_config || return 1

    make clean
    make $MKTHD && make install
}

function get_zlib () {
    tget https://www.zlib.net/${ZLIB}.tar.gz 
}

function set_compile_env_for_target () {
    export CC=${_CC}
    export AR=${_AR}
    export LD=${_LD}
    export RANLIB=${_RANLIB}
    export STRIP=${_STRIP}
}


## 添加环境变量
if [ -d "${BUILD_HOST_PATH}"  ]; then
    export PATH=${PATH}:${BUILD_HOST_PATH}
fi

# 获取 工具链所在位置 下面的操作为的是在 CMakeLists.txt 中插入下面内容
##export GCC_FULL_PATH=`whereis ${_CC} | awk -F: '{ print $2 }' | awk '{print $1}'` # 防止多个结果
##export GCC_DIR=`dirname ${GCC_FULL_PATH}/`

function make_dirs () {
    #为了方便管理，创建有关的目录
    mkdir -pv $CODE_PATH
    mkdir -pv $OUTPUT_PATH
    mkdir -pv $ARCHIVE_PATH
}

function tget () { #try wget
    local filename=`basename $1`
    echo "Downloading [${filename}]..."
    if [ ! -f ${filename} ];then
        wget $1
    fi

    echo "[OK] Downloaded [${filename}] "
}

function tgit () { #try git and tar
    local filename=`basename $1 | sed 's/.git//g'`

    echo "Clone [${filename}]..."
    if [ ! -f ${filename}.tgz ];then
        git clone $1
        rm ${filename}/.git* -rf
        echo "Making a tar file."
        tar -zcf ${filename}.tgz ${filename}
        rm ${filename} -rf
    fi

    echo "[OK] Cloned [${filename}] "
}

function tar_package () {
    cd ${ARCHIVE_PATH}
    for TAR in `find . -maxdepth 1 -mindepth 1 -type f`
    do
        echo "Untar $TAR..."
        tar -xf $TAR -C  ${CODE_PATH}
    done
    cd $BASE
}

function require () {
    echo "Checking [$1]"
    command -v $1 >/dev/null 2>&1 || { echo >&2 "Aborted : Require \"$1\" but not found."; exit 1; }
}

make_dirs
require ${_CC} || return 1
